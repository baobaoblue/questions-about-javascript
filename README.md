### 1.数组扁平化；
* 方法一：递归
```
function flatten(arr){
	var res = [];
	//判断数组的自相是否是数组，如果是则递归，反之push
	if(Array.isArray(arr[i])){
	    res = res.concat(flatten(arr[i]))
	}else{
	    res.push(arr[i];
	}
}
return res;
const arr = [1,[2,3,[4]],5]
console.log('扁平化后：',flatten(arr));

```
* 方法二：reduce()
```
function flatten(arr){
	return arr.reduce(function(prev,item){
		return prev.concat(Array.isArray(item)?flatten(item):item)
	},[])
}
const arr = [1,[2,3,[4]],5]
console.log('扁平化后：',flatten(arr));

```

### 2.面向对象编程与面向过程编程的区别

面向对象和面向过程并不是完全相对的、完全独立的，是相互相成的关系；

面向对象：针对对象来进行执行某些动作，对象有自己的属性和方法。

面向过程：完成一个事件就是将不同的动作函数按需求调用

### 3.如何实现继承跟封装

封装的几种方式：构造函数、原型prototype、闭包实现的封装

继承：
* 类式继承：通过子类的原型prototype对象实例化来实现的。缺点就是：一个子类的实例原型从父类构造函数中继承来的共有属性，一个子类的实例如果更改了这个引用类型就会直接影响到其他子类

* 构造函数式继承：通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的。通过call/apply/bind直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题。由于这种类型的继承没有涉及原型prototype,所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中。

* 组合继承：类式继承+构造函数继承,汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响

* 寄生式继承：通过在一个函数内的过渡对象实现继承并返回新对象的方式，称之为寄生式继承。寄生就像寄生虫一样寄托于某个对象内部生长。就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。

* 寄生组合式继承：寄生式继承+构造函数式继承，先创建了父类，还有父类的原型方法，然后创建子类，并在构造函数中实现构造函数式继承，然后又通过寄生式继承了父类 原型，最后又对子类添加了一些原型方法。


### 4.sass的计算属性对页面性能有无影响

sass只是中间形态，最终执行的是css

5.vue2.0跟vue3.0分别是如何实现双向绑定的

vue2.0 

vue3.0 将带来一个基于 Proxy 的 observer 实现，它可以提供覆盖语言 (JavaScript——译注) 全范围的响应式能力，消除了当前 Vue 2 系列中基于 Object.defineProperty 所存在的一些局限，这些局限包括：

对属性的添加、删除动作的监测；

对数组基于下标的修改、对于 .length 修改的监测；

对 Map、Set、WeakMap 和 WeakSet 的支持；

另外，新的 observer还提供了如下的一些特性：
公开的用于创建 observable 的 API：这为小型到中型的应用提供了一种轻量级的、极其简单的跨组件状态管理解决方案。
默认为惰性监测（Lazy Observation）。在 2.x版本中，任何响应式数据，不管它的大小如何都会在启动的时候监测功能。如果数据量很大的话，在应用启动的时候就可能造成严重的性能消耗。而在3.x 版本中，只有应用的初始可见部分所用到的数据会被监测，更不用说这种监测方案本身其实也是更加快的。

6.Object.definedProperty（）和proxy的区别

7.vue hash路由跟history路由的区别

8.vue 的nexttick实现原理

9.webpack打包过程

10.webpack 热部署的原理

11：webpack打包过慢跟打包出来文件体积过大怎么处理

未完待续...
